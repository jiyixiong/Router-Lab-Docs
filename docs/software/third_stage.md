## 组队评测

第三部分是针对组队的测试，一个组一般是三个人，网络拓扑与单人测试相同，只不过此时 R1、R2、R3 都运行同学的代码。在组队完成后，队长可以在 TANLabs 上进行评测，设置 R1 R2 R3 分别对应同学的哪一个版本的代码。同样地，需要标记一次评测为全组的最终成绩。

## 测试方法

测试方法：

1. 配置网络拓扑，在 R1 R2 R3 上分别运行三位同学的程序，分别定义 `ROUTER_R{1,2,3}` 宏定义编译后的路由器程序。
2. 等待 RIP 协议运行一段时间，一分钟后进行评测。
3. 在 PC1 上 `ping fd00::5:1` 若干次，在 PC2 上 `ping fd00::1:2` 若干次，测试 ICMP 连通性。
4. 在 PC1 和 PC2 上各监听 80 端口，各自通过 nc 访问对方，测试 TCP 连通性。
5. 在 PC1 上 `ping fd00::5:1 -t 1`，应当出现 `Time exceeded` 的响应（R1 发给 PC1），再把 HLim 改成 2（R2 发给 PC1）和 3（R3 发给 PC1），测试三个路由器的 HLim=0 的处理，再反过来从 PC2 上 `ping fd00::1:2 -t 1`，也应当出现 `Time exceeded` 的响应（R3 发给 PC2），再把 HLim 改成 2（R2 发给 PC2）和 3（R1 发给 PC2） 。
6. 在 PC1 上 `ping fd00::233:233`，应当出现 `Destination Net Unreachable`（R1 发给 PC1），在 PC2 上 `ping fd00::233:233` 亦然（R3 发给 PC2）。
7. 在 PC2 上运行 `iperf3 -s`，在 PC1 上运行 `iperf3 -c fd00::5:1 -O 5 -P 10`，按照 Bitrate 给出分数，测试转发的效率。
8. 在 PC2 上运行 `iperf3 -s`，在 PC1 上运行 `iperf3 -c fd00::5:1 -u -l 16 -t 5 -b 1G -O 5`，按照接收方实际收到的 Datagram 数量每秒（即 Total Datagram 减去 Lost，再除以时间）给出分数，测试转发的效率。
9. 小规模路由表压力测试：在 PC1 上开启 bird，配置 `fd00::a:0/112` ~ `fd00::ff:0/112` 共两百多条新的路由，在 PC1 上配置 `fd00::14:1/128` 和 `fd00::ff:0/128` 的地址，从 PC2 ping 这两个地址可以成功。
10. 中规模路由表压力测试：在上一步的基础上，在 PC1 上增加 `fd00::1:0:0/112` ~ `fd00::8:ff:0/112` 共 2048 条新路由，在 PC1 上配置 `fd00::1:2:3/128` 和 `fd00::8:7:6/128` 的地址，从 PC2 ping 这两个地址可以成功。
11. 大规模路由表压力测试：在上一步的基础上，在 PC1 上增加 `2409:8000::/20` 到 `2409:8f6f::/32` 共 2732 条 AS9808 的新路由，在 PC1 上配置 `2409:8087:4c16:1111:2222:3333:4444:5555/128` 和 `2409:8931:8210:5555:4444:3333:2222:1111/128` 的地址，从 PC2 ping 这两个地址可以成功。

在过程中，如果路由器程序崩溃退出，后续的测试项目都会失败。在实验平台上，可以看到功能和性能的原始评测结果，不公布最终成绩。

由于性能会计入分数，请在通过所有功能测试后，检查一下是否删除了不必要的影响性能的调试代码。

对于第 9 步到第 11 步，在实验框架最新版的 `Setup/part9to11` 目录下有对应的配置文件。为了进行第 9 步到第 11 步的评测（以 BIRD v1.6 为例子），需要：

1. 在 PC1 上运行 BIRD，使用的配置是 `Setup/part9to11/bird-pc1.conf`：`sudo ip netns exec PC1 bird6 -c bird-pc1.conf -s bird-pc1.ctl -d`
2. 接着，在 PC1 上把 lo 网络接口配置起来：`sudo ip netns exec PC1 ip l set lo up`
3. 配置第 9 步指定的 IP 地址：`sudo ip netns exec PC1 ip a add fd00::14:1/128 dev pc1r1`，其他依此类推
4. 启用 part9 的配置：`sudo birdc -s bird-pc1.ctl enable part9`
5. 此时应该可以看到 part9 的配置已经启用，可以在 PC2 上进行 ping 的测试了
6. 按照同样的方法，完成第 10 步和第 11 步的测试

PC1 和 PC2 的路由：

```text
PC1:
default via fd00::1:1 dev pc1r1
fd00::1:0/112 dev pc1r1 scope link
PC2:
default via fd00::5:2 dev pc2r3
fd00::5:0/112 dev pc2r3 scope link
```

初始情况下 R1 R2 R3 都只有对应的直连路由，只有在正确地运行 RIP 协议后，才能从 PC1 ping 通 PC2。

??? warning "容易出错的地方"

    1. 自己或者队友的水平分割实现的不正确
    2. RIP 中有一些字段不符合要求
    3. USB 网卡的插入顺序不对
    4. 直连路由配置不正确
    5. PC1 和 PC2 配置不正确，ICMP 报文根本没有发给 R1 和 R3
    6. Windows 默认不响应 ICMP Echo Request，[解决方法](https://kb.iu.edu/d/aopy)
    7. BIRD 配置不正确，如网卡名称和实际情况对不上

??? tip "提升转发性能的方法"

    1. 去掉转发时的调试输出
    2. 优化路由表查询算法

??? tip "支持较大路由表的方法"

    1. 发送 RIPng Response 时按照 RFC 2080 要求进行切分
    2. 完善路由表更新算法
    3. 完善路由表查询算法

## 本地测试

基本与第二阶段的本地测试相同，不同点在于：

1. 此时 R1 R2 R3 运行的都是同学编写的路由器，注意要分别运行 r1-r3 目录下的路由器程序，否则会报错
2. R1 和 R3 不再运行 BIRD，也不需要配置 Linux 的 IPv6 地址，因此不能在 R1-R3 上直接运行 ping 等程序
3. R1 和 R3 关闭了 Linux 的 IPv6 转发功能
4. 在 PC1 上运行 BIRD 以注入不同规模的路由表

!!! tips "第三阶段实验是怎么设计出来的？"

    第三阶段和第二阶段的区别在于，第二阶段是将同学的路由器实现与标准的实现进行互联，而第三阶段则是将三个同学的路由器分别运行到 R1-R3，进行互联。这个设计的启发来自于商业网络设备的测试流程中很重要的一环：互操作测试。虽然各个协议都有一些标准，但不同厂商的实现可能会有一些细微的差别，但不能因为厂商之间实现的差异就导致协议不能正常工作。在本实验中也是一样，虽然同学实现的路由器和 BIRD 实现可以互联，但不代表和其他同学的实现就可以互联。比如最常见的例子，BIRD 会忽略掉不合法的 RIPng 条目，只考虑那些合法的；但同学实现的路由器在这种情况下可能会有错误的行为。往年就出现过这样的情况，两个同学写的都是错的，恰好负负得正，两个同学之间可以互联，但是不能和第三个同学的路由器互联。这也启发了编程作业中 protocol 的设计。
